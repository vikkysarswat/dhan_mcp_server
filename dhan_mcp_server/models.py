"""
Pydantic models for Dhan API data validation and serialization
"""

from typing import Optional, List, Literal
from pydantic import BaseModel, Field
from datetime import datetime
from enum import Enum


# Enums for better type safety
class TransactionType(str, Enum):
    BUY = "BUY"
    SELL = "SELL"


class ExchangeSegment(str, Enum):
    NSE_EQ = "NSE_EQ"
    NSE_FNO = "NSE_FNO"
    NSE_CURR = "NSE_CURR"
    BSE_EQ = "BSE_EQ"
    BSE_FNO = "BSE_FNO"
    BSE_CURR = "BSE_CURR"
    MCX_COMM = "MCX_COMM"


class ProductType(str, Enum):
    CNC = "CNC"
    INTRADAY = "INTRADAY"
    MARGIN = "MARGIN"
    MTF = "MTF"
    CO = "CO"
    BO = "BO"


class OrderType(str, Enum):
    LIMIT = "LIMIT"
    MARKET = "MARKET"
    STOP_LOSS = "STOP_LOSS"
    STOP_LOSS_MARKET = "STOP_LOSS_MARKET"


class Validity(str, Enum):
    DAY = "DAY"
    IOC = "IOC"


class OrderStatus(str, Enum):
    TRANSIT = "TRANSIT"
    PENDING = "PENDING"
    REJECTED = "REJECTED"
    CANCELLED = "CANCELLED"
    PART_TRADED = "PART_TRADED"
    TRADED = "TRADED"
    EXPIRED = "EXPIRED"
    CONFIRM = "CONFIRM"


class LegName(str, Enum):
    ENTRY_LEG = "ENTRY_LEG"
    TARGET_LEG = "TARGET_LEG"
    STOP_LOSS_LEG = "STOP_LOSS_LEG"


class OptionType(str, Enum):
    CALL = "CALL"
    PUT = "PUT"


class AMOTime(str, Enum):
    PRE_OPEN = "PRE_OPEN"
    OPEN = "OPEN"
    OPEN_30 = "OPEN_30"
    OPEN_60 = "OPEN_60"


# Request Models
class OrderRequest(BaseModel):
    """Model for placing a new order"""
    dhanClientId: str = Field(..., description="User specific identification generated by Dhan")
    correlationId: Optional[str] = Field(None, description="User/partner generated id for tracking")
    transactionType: TransactionType = Field(..., description="The trading side of transaction")
    exchangeSegment: ExchangeSegment = Field(..., description="Exchange Segment")
    productType: ProductType = Field(..., description="Product type")
    orderType: OrderType = Field(..., description="Order Type")
    validity: Validity = Field(..., description="Validity of Order")
    securityId: str = Field(..., description="Exchange standard ID for each scrip")
    quantity: int = Field(..., description="Number of shares for the order", gt=0)
    disclosedQuantity: Optional[int] = Field(None, description="Number of shares visible")
    price: Optional[float] = Field(None, description="Price at which order is placed")
    triggerPrice: Optional[float] = Field(None, description="Trigger price for SL orders")
    validity: Validity = Field(..., description="Validity of Order")


# Response Models
class OrderResponse(BaseModel):
    """Model for order placement response"""
    orderId: str = Field(..., description="Order specific identification generated by Dhan")
    orderStatus: OrderStatus = Field(..., description="Last updated status of the order")


class OrderDetails(BaseModel):
    """Model for detailed order information"""
    dhanClientId: str = Field(..., description="User specific identification generated by Dhan")
    orderId: str = Field(..., description="Order specific identification generated by Dhan")
    correlationId: Optional[str] = Field(None, description="User/partner generated id for tracking")
    orderStatus: OrderStatus = Field(..., description="Last updated status of the order")
    transactionType: TransactionType = Field(..., description="The trading side of transaction")
    exchangeSegment: ExchangeSegment = Field(..., description="Exchange Segment")
    productType: ProductType = Field(..., description="Product type of trade")
    orderType: OrderType = Field(..., description="Order Type")
    validity: Validity = Field(..., description="Validity of Order")
    tradingSymbol: Optional[str] = Field(None, description="Trading symbol")
    securityId: str = Field(..., description="Exchange standard ID for each scrip")
    quantity: int = Field(..., description="Number of shares for the order")
    disclosedQuantity: int = Field(..., description="Number of shares visible")
    price: float = Field(..., description="Price at which order is placed")
    triggerPrice: float = Field(..., description="Price at which order is triggered")
    afterMarketOrder: bool = Field(..., description="Whether order is AMO")
    boProfitValue: float = Field(..., description="Bracket Order Target Price change")
    boStopLossValue: float = Field(..., description="Bracket Order Stop Loss Price change")
    legName: Optional[LegName] = Field(None, description="Leg identification for BO")
    createTime: str = Field(..., description="Time at which the order is created")
    updateTime: str = Field(..., description="Time at which the last activity happened")
    exchangeTime: str = Field(..., description="Time at which order reached at exchange")
    drvExpiryDate: Optional[str] = Field(None, description="For F&O, expiry date of contract")
    drvOptionType: Optional[OptionType] = Field(None, description="Type of Option")
    drvStrikePrice: float = Field(..., description="For Options, Strike Price")
    omsErrorCode: Optional[str] = Field(None, description="Error code if order is rejected")
    omsErrorDescription: Optional[str] = Field(None, description="Error description if order is rejected")
    algoId: Optional[str] = Field(None, description="Exchange Algo ID for Dhan")
    remainingQuantity: int = Field(..., description="Quantity pending to be traded")
    averageTradedPrice: float = Field(..., description="Average price at which order is traded")
    filledQty: int = Field(..., description="Quantity of order traded on Exchange")


class TradeDetails(BaseModel):
    """Model for trade information"""
    dhanClientId: str = Field(..., description="User specific identification generated by Dhan")
    orderId: str = Field(..., description="Order specific identification generated by Dhan")
    exchangeOrderId: str = Field(..., description="Order specific identification generated by exchange")
    exchangeTradeId: str = Field(..., description="Trade specific identification generated by exchange")
    transactionType: TransactionType = Field(..., description="The trading side of transaction")
    exchangeSegment: ExchangeSegment = Field(..., description="Exchange Segment")
    productType: ProductType = Field(..., description="Product type of trade")
    orderType: OrderType = Field(..., description="Order Type")
    tradingSymbol: str = Field(..., description="Trading symbol")
    securityId: str = Field(..., description="Exchange standard ID for each scrip")
    tradedQuantity: int = Field(..., description="Number of shares executed")
    tradedPrice: float = Field(..., description="Price at which trade is executed")
    createTime: str = Field(..., description="Time at which the order is created")
    updateTime: str = Field(..., description="Time at which the last activity happened")
    exchangeTime: str = Field(..., description="Time at which order reached at exchange")
    drvExpiryDate: Optional[str] = Field(None, description="For F&O, expiry date of contract")
    drvOptionType: Optional[OptionType] = Field(None, description="Type of Option")
    drvStrikePrice: float = Field(..., description="For Options, Strike Price")


class UserProfile(BaseModel):
    """Model for user profile information"""
    dhanClientId: str = Field(..., description="User specific identification generated by Dhan")
    tokenValidity: str = Field(..., description="Validity date and time for Token")
    activeSegment: str = Field(..., description="All active segments in user accounts")
    ddpi: str = Field(..., description="DDPI status of the user")
    mtf: str = Field(..., description="MTF consent status of the user")
    dataPlan: str = Field(..., description="Data API subscription status")
    dataValidity: str = Field(..., description="Validity date and time for Data API Subscription")


class MarginCalculatorRequest(BaseModel):
    """Model for margin calculation request"""
    dhanClientId: str = Field(..., description="User specific identification generated by Dhan")
    exchangeSegment: ExchangeSegment = Field(..., description="Exchange & Segment")
    transactionType: TransactionType = Field(..., description="The trading side of transaction")
    quantity: int = Field(..., description="Number of shares for the order", gt=0)
    productType: ProductType = Field(..., description="Product type")
    securityId: str = Field(..., description="Exchange standard ID for each scrip")
    price: float = Field(..., description="Price at which order is placed")
    triggerPrice: Optional[float] = Field(None, description="Price at which order is triggered (for SL orders)")


class MarginCalculatorResponse(BaseModel):
    """Model for margin calculation response"""
    totalMargin: float = Field(..., description="Total Margin required for placing the order")
    spanMargin: float = Field(..., description="SPAN margin required")
    exposureMargin: float = Field(..., description="Exposure margin required")
    availableBalance: float = Field(..., description="Available amount in trading account")
    variableMargin: float = Field(..., description="VAR or Variable margin required")
    insufficientBalance: float = Field(..., description="Insufficient amount (Available - Total)")
    brokerage: float = Field(..., description="Brokerage charges for executing order")
    leverage: str = Field(..., description="Margin leverage provided as per product type")


class FundLimitResponse(BaseModel):
    """Model for fund limit information"""
    dhanClientId: str = Field(..., description="User specific identification generated by Dhan")
    availabelBalance: float = Field(..., description="Available amount to trade")
    sodLimit: float = Field(..., description="Start of the day balance in account")
    collateralAmount: float = Field(..., description="Amount received against collateral")
    receiveableAmount: float = Field(..., description="Amount available against selling deliveries")
    utilizedAmount: float = Field(..., description="Amount utilised in the day")
    blockedPayoutAmount: float = Field(..., description="Amount blocked against payout request")
    withdrawableBalance: float = Field(..., description="Amount available to withdraw in bank account")


class LedgerEntry(BaseModel):
    """Model for ledger entry"""
    dhanClientId: str = Field(..., description="User specific identification generated by Dhan")
    narration: str = Field(..., description="Description of the ledger transaction")
    voucherdate: str = Field(..., description="Transaction Date")
    exchange: str = Field(..., description="Exchange information for the transaction")
    voucherdesc: str = Field(..., description="Nature of transaction")
    vouchernumber: str = Field(..., description="System generated transaction number")
    debit: str = Field(..., description="Debit amount")
    credit: str = Field(..., description="Credit amount")
    runbal: str = Field(..., description="Running Balance post transaction")


class HistoricalTradeDetails(BaseModel):
    """Model for historical trade information with charges"""
    dhanClientId: str = Field(..., description="User specific identification generated by Dhan")
    orderId: str = Field(..., description="Order specific identification generated by Dhan")
    exchangeOrderId: str = Field(..., description="Order specific identification generated by exchange")
    exchangeTradeId: str = Field(..., description="Trade specific identification generated by exchange")
    transactionType: TransactionType = Field(..., description="The trading side of transaction")
    exchangeSegment: ExchangeSegment = Field(..., description="Exchange Segment")
    productType: ProductType = Field(..., description="Product type of trade")
    orderType: OrderType = Field(..., description="Order Type")
    tradingSymbol: Optional[str] = Field(None, description="Trading symbol")
    customSymbol: str = Field(..., description="Trading Symbol as per Dhan")
    securityId: str = Field(..., description="Exchange standard ID for each scrip")
    tradedQuantity: int = Field(..., description="Number of shares executed")
    tradedPrice: float = Field(..., description="Price at which trade is executed")
    isin: str = Field(..., description="Universal standard ID for each scrip")
    instrument: str = Field(..., description="Type of Instrument (EQUITY/DERIVATIVES)")
    sebiTax: float = Field(..., description="SEBI Turnover Charges")
    stt: float = Field(..., description="Securities Transactions Tax")
    brokerageCharges: float = Field(..., description="Brokerage charges by Dhan")
    serviceTax: float = Field(..., description="Applicable Service Tax")
    exchangeTransactionCharges: float = Field(..., description="Exchange Transaction Charge")
    stampDuty: float = Field(..., description="Stamp Duty Charges")
    createTime: str = Field(..., description="Time at which the order is created")
    updateTime: str = Field(..., description="Time at which the last activity happened")
    exchangeTime: str = Field(..., description="Time at which order reached at exchange")
    drvExpiryDate: Optional[str] = Field(None, description="For F&O, expiry date of contract")
    drvOptionType: Optional[OptionType] = Field(None, description="Type of Option")
    drvStrikePrice: float = Field(..., description="For Options, Strike Price")


class MarketQuoteDepth(BaseModel):
    """Model for market depth data"""
    quantity: int = Field(..., description="Quantity at this depth")
    orders: int = Field(..., description="Number of orders at this depth")
    price: float = Field(..., description="Price at this depth")


class MarketDepthData(BaseModel):
    """Model for market depth response"""
    buy: List[MarketQuoteDepth] = Field(..., description="Buy side depth (up to 5 levels)")
    sell: List[MarketQuoteDepth] = Field(..., description="Sell side depth (up to 5 levels)")


class OHLCData(BaseModel):
    """Model for OHLC data"""
    open: float = Field(..., description="Opening price")
    high: float = Field(..., description="High price")
    low: float = Field(..., description="Low price")
    close: float = Field(..., description="Closing price")


class MarketQuote(BaseModel):
    """Model for complete market quote"""
    last_price: float = Field(..., description="Last traded price")
    last_quantity: Optional[int] = Field(None, description="Last traded quantity")
    last_trade_time: Optional[str] = Field(None, description="Last trade time")
    volume: Optional[int] = Field(None, description="Total volume")
    average_price: Optional[float] = Field(None, description="Volume weighted average price")
    buy_quantity: Optional[int] = Field(None, description="Total buy quantity")
    sell_quantity: Optional[int] = Field(None, description="Total sell quantity")
    ohlc: Optional[OHLCData] = Field(None, description="OHLC data")
    depth: Optional[MarketDepthData] = Field(None, description="Market depth")
    net_change: Optional[float] = Field(None, description="Net change from previous close")
    upper_circuit_limit: Optional[float] = Field(None, description="Upper circuit limit")
    lower_circuit_limit: Optional[float] = Field(None, description="Lower circuit limit")
    oi: Optional[int] = Field(None, description="Open Interest (for derivatives)")
    oi_day_high: Optional[int] = Field(None, description="Day's highest OI")
    oi_day_low: Optional[int] = Field(None, description="Day's lowest OI")


class HistoricalDataResponse(BaseModel):
    """Model for historical/intraday data response"""
    open: List[float] = Field(..., description="Opening prices")
    high: List[float] = Field(..., description="High prices")
    low: List[float] = Field(..., description="Low prices")
    close: List[float] = Field(..., description="Closing prices")
    volume: List[int] = Field(..., description="Volume data")
    timestamp: List[int] = Field(..., description="Epoch timestamps")
    open_interest: List[int] = Field(..., description="Open Interest data")


class DhanError(BaseModel):
    """Model for API error responses"""
    errorType: str = Field(..., description="Type of error")
    errorCode: str = Field(..., description="Error code")
    errorMessage: str = Field(..., description="Error message description")


# Validation helpers for new models
def validate_margin_request(data: dict) -> MarginCalculatorRequest:
    """Validate and create MarginCalculatorRequest from dictionary"""
    return MarginCalculatorRequest(**data)


def convert_margin_request_for_api(request: MarginCalculatorRequest) -> dict:
    """Convert MarginCalculatorRequest to API format"""
    data = request.model_dump(exclude_none=True)

    # Set default trigger price if not provided
    if "triggerPrice" not in data:
        data["triggerPrice"] = 0

    return data


# Validation helpers
def validate_order_request(data: dict) -> OrderRequest:
    """Validate and create OrderRequest from dictionary"""
    return OrderRequest(**data)


def validate_modify_request(data: dict) -> OrderModifyRequest:
    """Validate and create OrderModifyRequest from dictionary"""
    return OrderModifyRequest(**data)


# Utility functions for data conversion
def convert_order_for_api(order: OrderRequest) -> dict:
    """Convert OrderRequest to API format with proper string conversions"""
    data = order.model_dump(exclude_none=True)

    # Convert numeric fields to strings as expected by API
    if "quantity" in data:
        data["quantity"] = str(data["quantity"])
    if "price" in data:
        data["price"] = str(data["price"])
    if "triggerPrice" in data:
        data["triggerPrice"] = str(data["triggerPrice"])
    if "disclosedQuantity" in data:
        data["disclosedQuantity"] = str(data["disclosedQuantity"])

    # Set empty strings for optional fields that aren't provided
    optional_fields = ["correlationId", "price", "triggerPrice", "disclosedQuantity",
                       "amoTime", "boProfitValue", "boStopLossValue"]
    for field in optional_fields:
        if field not in data:
            data[field] = ""

    return data


def convert_modify_for_api(modify: OrderModifyRequest) -> dict:
    """Convert OrderModifyRequest to API format with proper string conversions"""
    data = modify.model_dump(exclude_none=True)

    # Convert numeric fields to strings
    if "quantity" in data:
        data["quantity"] = str(data["quantity"])
    if "price" in data:
        data["price"] = str(data["price"])
    if "triggerPrice" in data:
        data["triggerPrice"] = str(data["triggerPrice"])
    if "disclosedQuantity" in data:
        data["disclosedQuantity"] = str(data["disclosedQuantity"])

    # Set empty strings for optional fields
    optional_fields = ["legName", "triggerPrice", "disclosedQuantity"]
    for field in optional_fields:
        if field not in data:
            data[field] = ""

    return dataNone, description="Price at which order is triggered"
    afterMarketOrder: bool = Field(False, description="Flag for orders placed after market hours")
    amoTime: Optional[AMOTime] = Field(None, description="Timing for after market order")
    boProfitValue: Optional[float] = Field(None, description="Bracket Order Target Price change")
    boStopLossValue: Optional[float] = Field(None, description="Bracket Order Stop Loss Price change")


class OrderModifyRequest(BaseModel):
    """Model for modifying an existing order"""
    dhanClientId: str = Field(..., description="User specific identification generated by Dhan")
    orderId: str = Field(..., description="Order specific identification generated by Dhan")
    orderType: OrderType = Field(..., description="Order Type")
    legName: Optional[LegName] = Field(None, description="Leg to modify for BO & CO")
    quantity: Optional[int] = Field(None, description="Quantity to be modified", gt=0)
    price: Optional[float] = Field(None, description="Price to be modified")
    disclosedQuantity: Optional[int] = Field(None, description="Number of shares visible")
    triggerPrice: Optional[float] = Field(